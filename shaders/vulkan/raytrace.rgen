#version 460
#extension GL_EXT_ray_tracing : require

struct Camera {
    mat4 view_proj;     // Camera view * projection
    mat4 inverse_view;  // Camera inverse view matrix
    mat4 inverse_proj;  // Camera inverse projection matrix
};

struct World {
    vec3 top_color;
    vec3 bottom_color;
};

struct HitRecord {
    bool is_hit;
    // float hit_distance;
    // bool is_front_face;
    // vec3 world_position;
    // vec3 world_normal;
};

layout(location = 0) rayPayloadEXT HitRecord hit_record;

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1) uniform _Camera { Camera camera; };
layout(set = 0, binding = 2) uniform _World { World world; };
layout(set = 1, binding = 0, rgba32f) uniform image2D image;

vec3 sample_world(vec3 origin, vec3 direction) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    float cosine_similarity = dot(direction, up) / (length(direction) * length(up));
    vec3 sky_color = mix(world.bottom_color, world.top_color, (cosine_similarity + 1.0) * 0.5);
    return sky_color;
}

void main() {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = in_uv * 2.0 - 1.0;

    vec4 ray_origin = camera.inverse_view * vec4(0, 0, 0, 1);
    vec4 ray_target = camera.inverse_proj * vec4(d.x, d.y, 1, 1);
    vec4 ray_direction = camera.inverse_view * vec4(normalize(ray_target.xyz), 0);

    uint ray_flags = gl_RayFlagsOpaqueEXT;
    float t_min = 0.001;
    float t_max = 10000.0;

    vec3 light = vec3(0.0, 0.0, 0.0);
    vec3 attenuation = vec3(1.0, 1.0, 1.0);

    traceRayEXT(
        tlas,              // acceleration structure
        ray_flags,         // rayFlags
        0xFF,              // cullMask
        0,                 // sbtRecordOffset
        0,                 // sbtRecordStride
        0,                 // missIndex
        ray_origin.xyz,    // ray origin
        t_min,             // ray min range
        ray_direction.xyz, // ray direction
        t_max,             // ray max range
        0                  // payload (location = 0)
    );

    if (hit_record.is_hit) {
        // TODO: do the thing
    } else {
        light += sample_world(ray_origin.xyz, ray_direction.xyz);
    }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(light, 1.0));
}
