#version 460
#extension GL_EXT_ray_tracing : require

#include "common.glsl"

struct Camera {
    mat4 view_proj;     // Camera view * projection
    mat4 inverse_view;  // Camera inverse view matrix
    mat4 inverse_proj;  // Camera inverse projection matrix
};

struct World {
    vec3 top_color;
    vec3 bottom_color;
};

struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    vec3 emission_color;
    float emission_strength;
    float transmission;
    float ior;
};

layout(location = 0) rayPayloadEXT HitRecord hit_record;

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1) uniform _Camera { Camera camera; };
layout(set = 0, binding = 2) uniform _World { World world; };
layout(set = 0, binding = 5) buffer _Material { Material[] materials; };
layout(set = 1, binding = 0, rgba32f) uniform image2D image;

vec3 sample_world(vec3 origin, vec3 direction) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    float cosine_similarity = dot(direction, up) / (length(direction) * length(up));
    vec3 sky_color = mix(world.bottom_color, world.top_color, (cosine_similarity + 1.0) * 0.5);
    return sky_color;
}

void main() {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = in_uv * 2.0 - 1.0;

    vec4 ray_origin = camera.inverse_view * vec4(0, 0, 0, 1);
    vec4 ray_target = camera.inverse_proj * vec4(d.x, d.y, 1, 1);
    vec4 ray_direction = camera.inverse_view * vec4(normalize(ray_target.xyz), 0);

    vec3 light = vec3(0.0);
    vec3 attenuation = vec3(1.0);

    // TODO: control bounce count
    for (int bounces = 0; bounces < 1; ++bounces) {
        traceRayEXT(
            tlas,                 // acceleration structure
            gl_RayFlagsOpaqueEXT, // rayFlags
            0xFF,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            0,                    // missIndex
            ray_origin.xyz,       // ray origin
            0.001,                // ray min range (t_min)
            ray_direction.xyz,    // ray direction
            10000.0,              // ray max range (t_max)
            0                     // payload (location = 0)
        );

        if (hit_record.is_hit) {
            // TODO: do the thing
            light += materials[hit_record.material_index].albedo;
        } else {
            light += sample_world(ray_origin.xyz, ray_direction.xyz);
            break;
        }
    }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(light, 1.0));
}
